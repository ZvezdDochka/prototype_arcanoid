go.property("speed", 0)

local function limitX(self, x)
	local width = go.get("#sprite", "size.x")
	--if (x - width/2) <= 0 then
	if x <= 0 then
		self.x_mouse_pos = width/2
	--elseif (x + width/2) >= SCREEN_WIDTH then
	elseif x >= SCREEN_WIDTH then
		self.x_mouse_pos = SCREEN_WIDTH - width/2
	else
		self.x_mouse_pos = x
	end
end

function init(self)
	msg.post(".", "acquire_input_focus")
	--msg.post("#hands_collision", "disable")
	self.empty = true
end

function fixed_update(self, dt)
	if self.x_mouse_pos then
		self.pos = go.get_world_position()
		
		if self.last_pos then
			local sp = math.abs(self.last_pos.x - self.pos.x)
			if sp ~= self.speed then
				self.speed = (math.abs(self.last_pos.x - self.pos.x))/dt
			end
		end
		
		go.set_position(vmath.vector3(self.x_mouse_pos, self.pos.y, self.pos.z)) -- двигаем платформу при движении мыши
		self.last_pos = self.pos
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("Return_world_coordinate") then -- получаем позицию мыши в мировых координатах
		limitX(self, message.x) -- ограничиваем по краям
	end
end

function on_input(self, action_id, action)
	msg.post("@render:", "Get_world_coordinate", {x = action.x, y = action.y, z = action.z}) -- отправлем запрос на получение мировых координат

	if action_id == hash("touch") then
		if self.empty and action.pressed then
			--msg.post("/ball_generator#ball_generator", "generate_ball") -- спавним шарик на платформе
			msg.post("/spawn_ball_point#spawn_ball_point", "generate_ball") -- спавним шарик на платформе
			--self.empty = false
		end
	end
end
