function init(self)
	msg.post("#collisionobject", "disable") -- на старте отключаем у шарика физику
end

function fixed_update(self, dt)
	if self.speed then
		local speed = vmath.vector3(self.speed * self.direction.x, self.speed * self.direction.y, 0)
		local new_pos = go.get_position() + speed * dt -- вычисляем новую позицию шарика в зависимости от скорости, направления и временем отрисовки последнего кадра
		go.set_position(new_pos) -- двигаем шарик
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("contact_point_response") then -- обрабатываем столкновение шарика с поверхностями 
		if message.group == hash("out") then -- при столкновении с нижней границей поля
			print("GAME OVER")
		elseif message.group == hash("platform") or message.group == hash("top") or message.group == hash("left") or message.group == hash("right") then
			if message.other_id ~= self.prev_id then -- если до этого шарик касался другого объекта
				local normal = message.normal -- берем нормаль к поверхности
				print(normal)

				if normal.x ~= 0 then
					self.direction.x = math.abs(self.direction.x) * normal.x -- отталкиваем шарик в противоположном направлении по х
				end

				if normal.y ~= 0 then
					self.direction.y = math.abs(self.direction.y) * normal.y -- отталкиваем шарик в противоположном направлении по y
				end

				self.prev_id = message.other_id -- запоминаем объект, которого коснулся шарик
			end
		end
	end

	if message_id == hash("ball_released") then
		msg.post("#collisionobject", "enable")
		self.speed = 300
		local dir_x = message.dir
		self.direction = vmath.vector3(dir_x, 1, 0)
	end
end

function on_input(self, action_id, action)

end
